//
//  RandomImage.swift
//  dillabes
//
//  Created by Ryan Rotella on 2/22/25.
//

import SwiftUI
import UIKit

//generated by Claude.ai: https://claude.ai/chat/44faa413-672d-4075-898e-a89d05fe96ba

class ImageLoader: ObservableObject {
  @Published var albums: [Album] = [
    modalSoul, metaMus, spirSt, donuts, shining, welcome,
  ]
  @Published var albumImages = [UIImage]()

  //

  var tmer: Timer?

  //var albumInfo = [UIImage: String]()

  func randomize() {
    if !self.albums.isEmpty {
      self.albums.shuffle()
    }
  }

  //async - needs placeholder

  func loadImages() async {
    //claude.ai helped me understand that I was trying to update copies of Album structs, not the original in array
    for index in albums.indices {
      //var album
      if let url = URL(string: albums[index].imageLink),
        let (data, _) = try? await URLSession.shared.data(from: url),
        let image = UIImage(data: data)
      {
        DispatchQueue.main.async {
          //  self.albumImages.append(image)
          self.albums[index].changeCover(image)
          //print(album.cover)

        }

      }
    }
  }
}

//   for (album, urlString) in albumStrings {

//let albumStrings = [
//        "Modal Soul": //"https://i.discogs.com/vrRLAdjSll2Frd-Le6iDp4Od-tCsjidW1VnwzkV59h4/rs:fit/g:sm/q:90/h:600/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTMxNzgy/NjY4LTE3MzIxMzI2/NTQtMzU0OS5qcGVn.jpeg",
//        "Spiritual State": "https://m.media-amazon.com/images/I/61pB3CQ-XrS._UF1000,1000_QL80_.jpg",
//        "Metaphorical Music": "https://m.media-amazon.com/images/I/91tIjOEyHGL._UF1000,1000_QL80_.jpg",
//        "Donuts": "https://m.media-amazon.com/images/I/913nQ96vc6L._UF1000,1000_QL80_.jpg",
//        "The Shining": "https://f4.bcbits.com/img/0032067217_71.jpg",
//        "Welcome 2 Detroit" : "https://media.pitchfork.com/photos/5bb76ccab5a62d2d54af628d/16:9/w_1280,c_limit/JDilla_Welcome2Detroit.jpg"
//    ]

/*
 import SwiftUI
 import UIKit

 //generated by Claude.ai: https://claude.ai/chat/44faa413-672d-4075-898e-a89d05fe96ba



 struct ContentView: View {
    // @StateObject private
     @StateObject private var imageLoader = ImageLoader()

     let columns = [
         GridItem(.flexible()),
         GridItem(.flexible())
     ]

     let timer = Timer.publish(every: 3.5, on: .main, in: .common).autoconnect()


     var body: some View {

             VStack {
 //                Text("Loaded \(imageLoader.albumImages.count) images")
 //                    .padding()
                 //var data = imageLoader.albumImages.map({$0.randomElement()})


                 LazyVGrid(columns: columns, spacing: 40) {
                     ForEach(0..<imageLoader.albumImages.count, id: \.self) { index in
                         Image(uiImage: imageLoader.albumImages[index])
                             .resizable()
                             .aspectRatio(contentMode: .fit)
                             .scaledToFill()
                             .frame(width: 175, height: 175)
                             .cornerRadius(4)
                             .shadow(radius: 12)
                             .containerRelativeFrame(.horizontal) { size, axis in
                                 size * 0.8
                                 }

                     }
                 }
                 .background{
                     ScaledBezier(bezierPath: .bg1)
                         .stroke(lineWidth: 2)

                     ScaledBezier(bezierPath: .bg2)
                         .stroke(lineWidth: 2)

                     ScaledBezier(bezierPath: .bg3)
                         .stroke(lineWidth: 2)
                     //                                    .frame(width: 300, height: 300) as! Edge.Set
                     //.fill(color.red)
                 }
                 .onReceive(timer) {_ in
                     imageLoader.randomize()
                 }
                 .padding()
             }


         .task {
             await imageLoader.loadImages()
             imageLoader.randomize()

         }
     }
 }

 #Preview {
     ContentView()
 }


 extension UIBezierPath {
     static var bg1: UIBezierPath {

         let y: CGFloat = UIScreen.main.bounds.size.height
         let x: CGFloat = UIScreen.main.bounds.size.width
         let height: CGFloat = y/3
         let path = UIBezierPath()

         let fillColor: UIColor = .blue


         path.move(to: CGPoint(x: 0.0, y: height))
         path.addCurve(to: CGPoint(x: x, y: y), controlPoint1: CGPoint(x: 0.534, y: 0.7816), controlPoint2: CGPoint(x: 0.4529, y: 0.4205))
         path.addCurve(to: CGPoint(x: 0.9728, y: 0.8259), controlPoint1: CGPoint(x: 0.4922, y: 0.4949), controlPoint2: CGPoint(x: 0.0968, y: 0.8148))
         fillColor.setFill()
             path.fill()
         return path
     }

     static var bg2: UIBezierPath {
         let path = UIBezierPath()
         path.move(to: CGPoint(x: 0.0, y: 0.0))
         path.addCurve(to: CGPoint(x: 0.60, y: 0.70), controlPoint1: CGPoint(x: 0.234, y: 0.2816), controlPoint2: CGPoint(x: 0.5529, y: 0.5205))
 //        path.addCurve(to: CGPoint(x: 0.9728, y: 0.8259), controlPoint1: CGPoint(x: 0
         return path
     }
     static var bg3: UIBezierPath {
         let path = UIBezierPath()
         path.move(to: CGPoint(x: 0.534, y: 0.5816))
         path.addCurve(to: CGPoint(x: 0.0, y: 0.988), controlPoint1: CGPoint(x: 0.934, y: 0.7816), controlPoint2: CGPoint(x: 0.1529, y: 0.4205))
 //        path.addCurve(to: CGPoint(x: 0.9728, y: 0.8259), controlPoint1: CGPoint(x: 0.4922, y: 0.4949), controlPoint2: CGPoint(x: 1.0968, y: 0.4148))

         return path
     }
 }

 struct ScaledBezier: Shape {

     let bezierPath: UIBezierPath

     func path(in rect: CGRect) -> Path {
         let path = Path(bezierPath.cgPath)

         // Figure out how much bigger we need to make our path in order for it to fill the available space without clipping.
        let multiplier = min(rect.width, rect.height)

         // Create an affine transform that uses the multiplier for both dimensions equally.
        let transform = CGAffineTransform(scaleX: multiplier, y: multiplier)

         // Apply that scale and send back the result.
         return path
             .applying(transform)
     }
 }
 */
